#!/usr/bin/env bash
set -e
set -o pipefail

if [ "$name" != "Woost" -a "$1" != "nsbt" ]; then 
  echo -e "\e[33m######### YOU HAVE NOT STARTED NIX-SHELL #########\e[0m"
fi;

script_dir="$(dirname $0)"
sql_checksum_file="$script_dir/.sql_checksum"
sql_checksum_dir="$script_dir/dbMigration/core/sql"

function assure_db_migration() {
    new_checksum="$(find $sql_checksum_dir -type f -exec md5sum {} \; | sort -k 2 | md5sum)"
    old_checksum="$(cat $sql_checksum_file 2> /dev/null || true)"
    if [ "$old_checksum" != "$new_checksum" ]; then
        echo "$new_checksum" > $sql_checksum_file
        echo "New db migration available, building db-migration image"
        sbt dbMigration/docker
    fi
}

function docker_compose() {
    project="$1"
    stage="$2"
    add_args=""
    if [[ -n "$stage" ]] && [[ -f "$project/docker-compose.$stage.yml" ]]; then
        add_args="-f $project/docker-compose.$stage.yml"
    fi

    set +e
    output=$(docker-compose -p "$stage$project" -f $project/docker-compose.yml $add_args ${@:3} 2>&1 | tee /dev/tty )
    err=$?
    set -e

    if [[ -n "$(echo $output | grep -E 'manifest for woost/db-migration:[^ ]* not found')" ]]; then
        echo "Cannot find db-migration image, rebuilding..."
        sbt dbMigration/docker
        docker_compose $@
    elif [[ -n "$(echo $output | grep -E 'manifest for woost/[^ ]* not found')" ]]; then
        echo "Cannot find some docker image, rebuilding all images..."
        sbt docker
        docker_compose $@
    elif [[ $err -ne 0 ]]; then
        echo "docker-compose failed, exiting"
        exit 1
    fi
}
function postgres_nottycommand() {
    docker exec -i "devcore_postgres_1" "$@"
}
function postgres_command() {
    docker exec -it "devcore_postgres_1" "$@"
}
override_sbt_args="${@:2}" # all remaining arguments starting at 2
function sbt_with_args() {
    args="${@:1}"
    [ -n "$override_sbt_args" ] && args="$override_sbt_args"

    sbt $args
}
function sbt() {
    command sbt -Dquill.macro.log=false $EXTRASBTARGS $@
}

dockerhost_ip=`ip -4 addr show scope global dev docker0 | grep inet | awk '{print \$2}' | cut -d / -f 1`

FALLBACKVERSION="dirty" # When git is not available
[ -n "$TRAVIS_BRANCH" ] && VERSION=$TRAVIS_BRANCH || VERSION=`git rev-parse --abbrev-ref HEAD` || VERSION=$FALLBACKVERSION
[ $VERSION == "master" ] && VERSION="latest"


# TODO: if database docker image is not found, automatically do a migration
env_wust_version="WUST_VERSION=$VERSION"
env_wust_secret="WUST_AUTH_SECRET=secret WUST_USER=wust WUST_PASSWORD=wust WUST_PUSH_SUBJECT=push.dev@woost.space WUST_PUSH_PUBLIC_KEY=BDP21xA+AA6MyDK30zySyHYf78CimGpsv6svUm0dJaRgAjonSDeTlmE111Vj84jRdTKcLojrr5NtMlthXkpY+q0 WUST_PUSH_PRIVATE_KEY=or76yI5iDE+S9gWkVU2g0JuHyq4OD/AtwHTHefkoo3k"
env_wust_local="WUST_HOSTNAME=localhost DEV_DOCKERHOST_IP=$dockerhost_ip DOCKER_RESTART_POLICY=no"
env_postgres_secret="POSTGRES_PASSWORD=test"
env_postgres_local="POSTGRES_HOSTNAME=localhost POSTGRES_USER=wust POSTGRES_DB=wust POSTGRES_PORT_CORE=5433"
env_redis_local="REDIS_HOSTNAME=localhost REDIS_PORT_GITHUB=6380"

env_wust_local_connectivity="WUST_PORT=${WUST_PORT:-12345} WUST_WEB_PORT=${WUST_WEB_PORT:-8900}  WUST_CORE_PORT=${WUST_CORE_PORT:-8901} WUST_GITHUB_PORT=${WUST_GITHUB_PORT:-8902} DEV_SERVER_COMPRESS=${DEV_SERVER_COMPRESS:-false} SOURCEMAPS=${SOURCEMAPS:-false}"

if [[ -f tokens.sh ]]; then
    source tokens.sh
fi

function self() {
    case "$1" in
    psql)
        export $env_postgres_secret $env_postgres_local
        PGPASSWORD=$POSTGRES_PASSWORD psql -h $POSTGRES_HOSTNAME -U $POSTGRES_USER -p $POSTGRES_PORT_CORE ${@:2}
        # postgres_command psql -h localhost -U $POSTGRES_USER ${@:2}
        ;;
    pgcli)
        export $env_postgres_secret $env_postgres_local
        PGPASSWORD=$POSTGRES_PASSWORD pgcli -h $POSTGRES_HOSTNAME -U $POSTGRES_USER -p $POSTGRES_PORT_CORE ${@:2}
        ;;
    pgdump)
        postgres_command pg_dump --clean --if-exists -h localhost -U wust > $(date +"%F-%H-%M-%S-dev-postgres-backup.sql")
        ;;
    pgrestore)
        postgres_command psql -h localhost -U wust -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
        postgres_nottycommand psql --single-transaction --set ON_ERROR_STOP=on -h localhost -U wust --file=- < $2
        ;;
    pgrestorefromprod)
        postgres_command psql -h localhost -U wust -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
        ssh -C woost.space docker exec -i "wooststagingcore_postgres_1" pg_dump --clean --if-exists -h localhost -U wust | postgres_nottycommand psql --single-transaction --set ON_ERROR_STOP=on -h localhost -U wust --file=-
        ;;
    pgclean)
        postgres_command psql -h localhost -U wust -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
        ;;
    sbtWithPoll)
        # Only exports polling parameter and then falls through!
        export "EXTRASBTARGS=$EXTRASBTARGS -Dsbt.watch.mode=polling"
        ;&
    nsbt)
        nix-shell production.nix --run "./start sbt"
        ;;
    sbt)
        env="$env_wust_version $env_postgres_secret $env_wust_secret $env_postgres_local $env_redis_local $env_wust_local $env_wust_local_connectivity"
        echo -e "\e[1m\e[32m$env\e[0m"
        export $env

        assure_db_migration

        case "$2" in
        all)
            docker_compose core dev up -d db-migration
            docker_compose githubApp dev up -d redis
            ;;
        core)
            docker_compose core dev up -d db-migration
            ;;
        githubApp)
            docker_compose githubApp dev up -d redis
            ;;
        gitterApp)
            ;;
        slackApp)
            ;;
        *)
            docker_compose core dev up -d db-migration
            ;;
        esac

        set +e # after sbt crash or termination, still shut down docker containers
        sbt
        docker_compose core dev down
        ;;
    apps)
        env="$env_wust_version $env_postgres_secret $env_wust_secret $env_postgres_local $env_redis_local $env_wust_local $env_wust_local_connectivity"
        echo -e "- ENV: \e[1m\e[32m$env\e[0m"
        export $env

        assure_db_migration

        if [[ -z "$2" ]]; then
            docker_compose githubApp dev up -d
            docker_compose webApp dev up -d
        else
            docker_compose "$2" dev up -d
        fi
        ;;
    env)
        echo "export $env_wust_version $env_postgres_secret $env_wust_secret $env_postgres_local $env_redis_local $env_wust_local $env_wust_local_connectivity"
        ;;
    migrate)
        export $env_wust_version $env_postgres_secret $env_wust_local_connectivity

        assure_db_migration

        docker_compose core dev run db-migration
        ;;
    prodlocal)
        echo "to open production: (slash in the end is important)"
        echo "http://localhost:12345/apps/web/"
        env="$env_wust_version $env_postgres_secret $env_wust_secret $env_postgres_local $env_redis_local $env_wust_local $env_wust_local_connectivity"
        echo -e "- ENV: \e[1m\e[32m$env\e[0m"
        export $env
        sbt webApp/clean docker
        docker_compose webApp dev up -d
        docker_compose core dev up -d db-migration
        sbt dev
        ;;
    test)
        sbt docker
        sbt_with_args test
        self test.postgres
        self test.integration
        ;;
    test.postgres)
        docker_compose core test.postgres down -v
        export $env_wust_version $env_wust_local_connectivity
        docker_compose core test.postgres run db-migration
        docker_compose core test.postgres run test-postgres
        docker_compose core test.postgres down -v
        ;;
    test.integration)
        export $env_wust_version $env_postgres_secret $env_wust_secret $env_postgres_local $env_redis_local $env_wust_local_connectivity
        docker_compose core dev up -d
        docker_compose webApp dev up -d
        docker_compose core dev run db-migration
        postgres_command psql -U postgres --command="DROP DATABASE IF EXISTS wust_template"
        postgres_command psql -U postgres --command="CREATE DATABASE wust_template TEMPLATE wust"
        # sbt_with_args coverage it:test coverageReport
        sbt_with_args it:test
        docker_compose core dev down -v
        ;;
    *)
        cat <<EOF
    unknown option '$1', expected one of:

    sbt [ all | core | githubApp | gitterApp | slackApp | * ]
    sbtWithPoll # Activate watch mode
    nsbt        # Start sbt in a nix-shell

    psql [options]
    pgcli [options]
    pgdump
    pgrestore [file]
    pgrestorefromprod
    pgclean

    apps
    env
    migrate

    prodlocal

    test
    test.postgres
    test.integration

EOF
        exit 1

    esac
}

self $@
